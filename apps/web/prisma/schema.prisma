generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// Note: We don't manage auth.users - it's handled by Supabase
// User IDs are stored as strings and validated at the application layer

model Property {
  id           String    @id @default(uuid())
  userId       String    @map("user_id") @db.Uuid
  name         String
  address      String?
  yearBuilt    Int?      @map("year_built")
  squareFeet   Int?      @map("square_feet")
  propertyType String?   @map("property_type")
  purchaseDate DateTime? @map("purchase_date")
  lookupData   Json?     @map("lookup_data")
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")
  createdById  String    @map("created_by_id") @db.Uuid
  updatedById  String    @map("updated_by_id") @db.Uuid

  spaces        Space[]
  items         Item[]
  documents     Document[]
  conversations Conversation[]

  @@index([userId], map: "idx_properties_user_id")
  @@map("properties")
}

model Space {
  id          String   @id @default(uuid())
  propertyId  String   @map("property_id")
  name        String
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  createdById String   @map("created_by_id") @db.Uuid
  updatedById String   @map("updated_by_id") @db.Uuid

  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  items    Item[]

  @@index([propertyId], map: "idx_spaces_property_id")
  @@map("spaces")
}

model Item {
  id              String    @id @default(uuid())
  propertyId      String    @map("property_id")
  spaceId         String?   @map("space_id")
  parentId        String?   @map("parent_id")
  name            String
  category        String
  manufacturer    String?
  model           String?
  serialNumber    String?   @map("serial_number")
  acquiredDate    DateTime? @map("acquired_date")
  warrantyExpires DateTime? @map("warranty_expires")
  purchasePrice   Decimal?  @map("purchase_price")
  notes           String?
  searchText      String?   @map("search_text")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  createdById     String    @map("created_by_id") @db.Uuid
  updatedById     String    @map("updated_by_id") @db.Uuid

  property  Property   @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  space     Space?     @relation(fields: [spaceId], references: [id])
  parent    Item?      @relation("ItemHierarchy", fields: [parentId], references: [id])
  children  Item[]     @relation("ItemHierarchy")
  events    Event[]
  documents Document[]

  @@index([propertyId], map: "idx_items_property_id")
  @@index([spaceId], map: "idx_items_space_id")
  @@index([parentId], map: "idx_items_parent_id")
  @@index([category], map: "idx_items_category")
  @@map("items")
}

model Event {
  id          String    @id @default(uuid())
  itemId      String    @map("item_id")
  type        String
  date        DateTime
  description String?
  cost        Decimal?  @db.Decimal(10, 2)
  performedBy String?   @map("performed_by")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  createdById String    @map("created_by_id") @db.Uuid
  updatedById String    @map("updated_by_id") @db.Uuid

  item      Item       @relation(fields: [itemId], references: [id], onDelete: Cascade)
  documents Document[]

  @@index([itemId], map: "idx_events_item_id")
  @@index([date], map: "idx_events_date")
  @@map("events")
}

model Document {
  id            String    @id @default(uuid())
  propertyId    String    @map("property_id")
  itemId        String?   @map("item_id")
  eventId       String?   @map("event_id")
  type          String
  fileName      String    @map("file_name")
  storagePath   String    @map("storage_path")
  contentType   String    @map("content_type")
  sizeBytes     BigInt    @map("size_bytes")
  status        String    @default("pending")
  extractedText String?   @map("extracted_text")
  extractedData Json?     @map("extracted_data")
  resolveData   Json?     @map("resolve_data")
  documentDate  DateTime? @map("document_date")
  createdAt     DateTime  @default(now()) @map("created_at")
  createdById   String    @map("created_by_id") @db.Uuid

  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  item     Item?    @relation(fields: [itemId], references: [id])
  event    Event?   @relation(fields: [eventId], references: [id])

  @@index([propertyId], map: "idx_documents_property_id")
  @@index([itemId], map: "idx_documents_item_id")
  @@index([status], map: "idx_documents_status")
  @@map("documents")
}

model Conversation {
  id          String   @id @default(uuid())
  propertyId  String   @map("property_id")
  title       String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  createdById String   @map("created_by_id") @db.Uuid

  property Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  messages Message[]

  @@index([propertyId], map: "idx_conversations_property_id")
  @@map("conversations")
}

model Message {
  id             String   @id @default(uuid())
  conversationId String   @map("conversation_id")
  role           String
  content        String
  createdAt      DateTime @default(now()) @map("created_at")

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId], map: "idx_messages_conversation_id")
  @@map("messages")
}
